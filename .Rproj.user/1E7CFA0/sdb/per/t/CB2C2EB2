{
    "contents" : "\n#####################################################################################################\n############\n##                  FLIPKART GRIDLOCK HACKATHON - TRAFFIC SIGNAL OPTIMIZATION \n############\n#####################################################################################################\n\n###########################\n##### OBJECTIVE - \n###########################\n\n## solve Bangalore's Traffic Problem \n\n###########################\n##### OUR SOLUTION -\n###########################\n\n## Optimization of Traffic Signals based on real-time Google and Bing Map data\n  # => Currently applied to the SILK BOARD Junction [Busiest Junction of Bangalore, 7th Busiest across the nation]\n\n###########################\n##### Inputs - \n###########################\n\n## Google Maps Traffic Data [Using Google Map API] - \n  # 1. Wait Times at each signal \n\n## Bing Maps Traffic Data [Using Bing Map API] - Traffic Map Image at a given instant \n  # 1. Using Image Processing, extract the length of immediate heavy/moderate traffic at the signal\n  # 2. Using Image Processing, extract the length of heavy/moderate traffic at the complete stretch of road\n\n###########################\n##### Approach - \n###########################\n\n## The current system installed at Silk Board Junction switches cycle times 6 times a day.\n# But in our Exploratory Data Analysis, we found that this system is not efficient enough, as it is unable to take care of the traffic changes during the span of the day\n  # For e.g. \n      # Traffic from HSR side to Silk Board remains at peaks at around 10:00AM and then significantly drops till 12PM \n      # While the traffic from BTM has already peaked at 9AM and significantly drops afterwards\n      # The traffic signal time remains the same between 8AM and 12PM leading to huge jam in the morning from HSR to Silk Board\n\n## Now using the above mentioned Inputs, we have 3 variables (mentioned below)\n  # List of Variables -\n      ## Wait Time at the signal [ Taken 500 metres in all the 4 directions ]\n      ## Length of Immediate Heavy/Moderate Traffic at all the 4 traffic signal [ Using Image Processing ]\n      ## Length of Heavy/Moderate Traffic on the whole stretch on all the 4 roads [ Nearly 3 Kms in every directions]\n\n## using the above 3 Inputs, a single Traffic Congestion Index is calculated\n  # A weighted combination of all 3 variables is taken for creation of this new metric\n    ## The Weights are ascertained using a simple Linear Regression on multiple days of data\n      ## Weights => Wait Time = 0.6, Length of Immediate Traffic = 0.25, Length of Traffic on complete stretch = 0.15\n\n## Now there are 2 things that can be optimized - \n  # 1. Total cycle time [ The total time in which all the traffic signals become Green once]\n  # 2. Individual Traffic Signal Time \n    ## This is done using the Traffic Congestion Index calculated using the above variables and corresponding weights\n\n## Other Assumptions -\n  # The current signal cycle time varies between 110 and 280 seconds\n    ## We have taken a little little liberty and optimized the total cycle time between 90 and 360 seconds  [ ~20% buffer on each extreme ] \n    ## Also, the individual traffic signals can never be less than 15 seconds\n\n## Implementation Logic - \n  # The total Traffic Congestion Index at the Silk Board Junction will decide the Total Cycle Time\n    ## The total is calculated as a sum of individual Signals [3 in our case as Bommanahallli & Madiwala Signals go Green at the same instant]\n  # The individual Traffic Congestion Indices are then used to divide the Total Cycle Time calculated above\n\n## Impact Measurement - \n  # Impact of this whole logic has been tested and measured - The change in wait times can be simply calculated based on modified signal times\n  # Based on EDA, we have been able to establish the Man Hours Saved [ ~17% of every second at the signal ]\n  # Based on Statistics, we have been able to find the Reduction in CO2 Emissions and Fuel Consumption\n\n\n###########################\n##### CODE - \n###########################\n\n\n### Installing all the relevant libraries - [Uncomment only if a Library is not installed]\n\n## Comment and Ctrl+Shift+C to Uncomment and Then Comment again once done with module installations\n\n# install.packages(\"plyr\")\n# install.packages(\"jpeg\")\n# install.packages(\"png\")\n# install.packages(\"dplyr\")\n# install.packages(\"gmapsdistance\")\n# install.packages(\"ggmap\")\n# install.packages(\"XML\")\n# install.packages(\"RCurl\")\n# install.packages(\"methods\")\n# install.packages(\"stats\")\n# install.packages(\"RgoogleMaps\")\n# install.packages(\"svDialogs\")\n# install.packages(\"jsonlite\")\n\n###########################\n### Initializing all the required packages\n###########################\n\nlibrary(plyr)\nlibrary(jpeg)\nlibrary(png)\nlibrary(dplyr)\nlibrary(gmapsdistance)\nlibrary(ggmap)\nlibrary(XML)\nlibrary(RCurl)\nlibrary(methods)\nlibrary(stats)\nlibrary(RgoogleMaps)\nlibrary(svDialogs)\nlibrary(jsonlite)\n\n### Setting the Working Directory - [User Input] \n\n## The shared R project should be placed in this directory\n    ## It should contain the following files and codes - \n          # 1. silkboard_coordinates.csv\n          # 2. silk_board_road.jpeg\n          # 3. Traffic_Signal_Optimization_GridlockHack_R.R\n\nsetwd(dlgDir(default = getwd(), title = \"Select the Working Directory\")$res)\n\n###########################\n### Setting all the keys, constants and constraints in the code\n###########################\n\n# The below Google and Bing APIs are specially created for the Hackathon\n# Both these APIs correspond to the free versions\n# Ping Limits ==> Google - 2500 per day, Bing  - 125000 per month\n\ngoogle_api_key = \"AIzaSyAg1AeMusLDvBNxUIr-_clMeh84EE5izK0\"\nbing_api_key = \"AlMeeGk8ljiG13V9zVgpSlpl7WeNt1NzyODT648buA4x9dhBF0nFkY4G9DGqFZIt\"\n\n### Latitude and Longitude for All 4 traffic Signals at the Silk Board Junction \n\nhsr_btm_lat = 12.9172365\nhsr_btm_long = 77.6230248\nbtm_hsr_lat = 12.9172574\nbtm_hsr_long = 77.6224830 \nmadiwala_ec_lat = 12.9175868\nmadiwala_ec_long = 77.6227727 \nec_madiwala_lat = 12.9170901\nec_madiwala_long = 77.6226815 \n\n\n### Weights as described in the Approach above [Computed using Regression]\n\nalpha_wt = 0.6 \nalpha_ri = 0.25\nalpha_rw = 0.15\nconstant = 0\n\n### Impact Measurement Metrics -\n\nmanhours_saved = 0.173611\npeople_per_vehicle = 2.2\naverage_speed = 5 \nlanes = 4\nvehicle_length = 3.5\nfuel_wasted = 5000  # KG fuel wasted per day per signal [this number has been taken on the lower side - on busiest junction in Delhi this is around 12000]\nfuel_density = 0.75 # Fuel Density - To Convert KG fuel to Litre\nco2_emissions = 14451.25 # C02 Emissions per day per signal \n\n### Min and Max are Hard-coded based on 7 days of run-time [after removing the outliers]\n\ntci_min = 200\ntci_max = 900\n\n## Hard-Coded to take the liberty of finding the best cycle time [as explained above in the assumptions]\n\ncycle_time_min = 90\ncycle_time_max = 360\n\ndf = data.frame()\ndf_raw = data.frame()\ngt_data = data.frame()\n\nsb_coords = read.csv(\"silkboard_coordinates.csv\")\n\n### Plotting Latitude and Longitude for every pixel in the image\n\nlat_max = 12.94462\nlong_min = 77.59711\n\nsilk_board_lat = 12.917349\nsilk_board_long  = 77.622759\n\ngeomap_latitude = data.frame()\ngeomap_longitude = data.frame()\ngeomap = data.frame()\n\n\n###########################\n### Reading the Road data and corresponding manipulations\n###########################\n\nup_down_roads = readPNG(\"silk_board_roads.jpeg\")\nup_down_roads = up_down_roads*255\n\nmadiwala_ec_up = data.frame()\nmadiwala_ec_down = data.frame()\nbtm_hsr_down = data.frame()\nbtm_hsr_up = data.frame()\nup_down_roads_map = data.frame()\n\nfor (i in 1:640)\n{\n  for (j in 1:640)\n  {\n    up_down_roads_map[i,j] = paste(up_down_roads[i,j,1],up_down_roads[i,j,2],up_down_roads[i,j,3],sep = \",\")\n  }\n}\nmadiwala_ec_up = up_down_roads_map\nmadiwala_ec_down = madiwala_ec_up\nbtm_hsr_down = madiwala_ec_up\nbtm_hsr_up = madiwala_ec_up\n\nmadiwala_ec_up[madiwala_ec_up != \"100,0,0\"] = \"\"\nmadiwala_ec_down[madiwala_ec_down != \"0,0,0\"] = \"\"\nbtm_hsr_up[btm_hsr_up != \"0,100,0\"] = \"\"\nbtm_hsr_down[btm_hsr_down != \"0,0,100\"] = \"\"\n\nindex_madi_ec = data.frame()\nindex_ec_madi = data.frame()\nindex_hsr_btm = data.frame()\nindex_btm_hsr = data.frame()\n\nfor ( i in 1:640)\n{\n  for ( j in 1:640 )\n  {\n    if(up_down_roads_map[i,j] == \"100,0,0\")\n    {\n      index_madi_ec = rbind.fill(index_madi_ec,data.frame(i,j))    \n    }\n    if(up_down_roads_map[i,j] == \"0,0,0\")\n    {\n      index_ec_madi = rbind.fill(index_ec_madi,data.frame(i,j))    \n    }\n    if(up_down_roads_map[i,j] == \"0,100,0\")\n    {\n      index_btm_hsr = rbind.fill(index_btm_hsr,data.frame(i,j))    \n    }\n    if(up_down_roads_map[i,j] == \"0,0,100\")\n    {\n      index_hsr_btm = rbind.fill(index_hsr_btm,data.frame(i,j))    \n    }\n  }\n}\n\nmadi_ec_x = 327\nmadi_ec_y = 302\nec_madi_x = 332\nec_madi_y = 300\nhsr_btm_x = 329\nhsr_btm_y = 304\nbtm_hsr_x = 327\nbtm_hsr_y = 295\n\nindex_madi_ec$distance = sqrt((index_madi_ec[1:nrow(index_madi_ec),1]-madi_ec_x)^2 + (index_madi_ec[1:nrow(index_madi_ec),2]-madi_ec_y)^2)\nindex_dist_ec_madi = sqrt((index_madi_ec[1:nrow(index_madi_ec),1]-madi_ec_x)^2 + (index_madi_ec[1:nrow(index_madi_ec),2]-madi_ec_y)^2)\n\nindex_madi_ec$distance = sqrt((index_madi_ec$i-madi_ec_x)^2 + (index_madi_ec$j-madi_ec_y)^2)\nindex_ec_madi$distance = sqrt((index_ec_madi$i-ec_madi_x)^2 + (index_ec_madi$j-ec_madi_y)^2)\nindex_hsr_btm$distance = sqrt((index_hsr_btm$i-hsr_btm_x)^2 + (index_hsr_btm$j-hsr_btm_y)^2)\nindex_btm_hsr$distance = sqrt((index_btm_hsr$i-btm_hsr_x)^2 + (index_btm_hsr$j-btm_hsr_y)^2)\n\nindex_ec_madi = index_ec_madi[order(index_ec_madi$distance),]\nindex_madi_ec = index_madi_ec[order(index_madi_ec$distance),]\nindex_hsr_btm = index_hsr_btm[order(index_hsr_btm$distance),]\nindex_btm_hsr = index_btm_hsr[order(index_btm_hsr$distance),]\n\n###########################\n#### Putting everything in one infinite loop - [ Everything below the loop is 1 time activity and need not run again]\n###########################\ni = 1\nwhile (i>0)\n{\n  time1 = Sys.time()\n\n  ## Getting all the 4 current wait times for the 500 metre distance - \n  \n  hsr_btm_time = gmapsdistance(origin = sb_coords$origin_lat_long[sb_coords$Origin == \"HSR\"],destination =  sb_coords$dest_lat_long[sb_coords$Origin == \"HSR\"],mode = \"driving\",key = google_api_key)$Time\n  btm_hsr_time = gmapsdistance(origin = sb_coords$origin_lat_long[sb_coords$Origin == \"BTM\"],destination =  sb_coords$dest_lat_long[sb_coords$Origin == \"BTM\"],mode = \"driving\",key = google_api_key)$Time\n  ec_madiwala_time = gmapsdistance(origin = sb_coords$origin_lat_long[sb_coords$Origin == \"EC\"],destination =  sb_coords$dest_lat_long[sb_coords$Origin == \"EC\"],mode = \"driving\",key = google_api_key)$Time\n  madiwala_ec_time = gmapsdistance(origin = sb_coords$origin_lat_long[sb_coords$Origin == \"Madiwala\"],destination =  sb_coords$dest_lat_long[sb_coords$Origin == \"Madiwala\"],mode = \"driving\",key = google_api_key)$Time\n  \n  time = Sys.time()\n  \n  ## Reading the current Bing Map Image and storing it at the specified location\n  \n  filename = paste(\"outputs/mapsbj\",as.integer(Sys.time()),\".jpeg\",sep = \"_\")\n\n  image = GetBingMap(center=\"silk%20%board%20flyover\", zoom=14,mapArea = c(12.8979,77.6045,12.9379,77.6445),size = c(640,640), extraURL=\"&mapLayer=TrafficFlow\",apiKey=bing_api_key,verbose=1, destfile=filename)\n  image = readPNG(filename)\n  image = image*255\n  \n  ## Processing the Image using RGBs for each of the pixels in 640x640 matrix \n  \n  image_rgb = data.frame()\n  \n  for (i in 1:640)\n  {\n    for (j in 1:640)\n    {\n      image_rgb[i,j] = paste(image[i,j,1],image[i,j,2],image[i,j,3],sep = \",\")\n    }\n  }\n  \n  ## Dividing the image into 4 roads coming from Madiwala, Electronic City, HSR and BTM correspondingly\n  \n  index_madi_ec = index_madi_ec[,c(1:2)]\n  index_ec_madi = index_ec_madi[,c(1:2)]\n  index_hsr_btm = index_hsr_btm[,c(1:2)]\n  index_btm_hsr = index_btm_hsr[,c(1:2)]\n  \n  for ( i in 1:nrow(index_madi_ec))\n  {\n    index_madi_ec$rgb1[i] = image_rgb[index_madi_ec[i,1],index_madi_ec[i,2]]\n  }\n  \n  for ( i in 1:nrow(index_ec_madi))\n  {\n    index_ec_madi$rgb1[i] = image_rgb[index_ec_madi[i,1],index_ec_madi[i,2]]\n  }\n  \n  for ( i in 1:nrow(index_btm_hsr))\n  {\n    index_btm_hsr$rgb1[i] = image_rgb[index_btm_hsr[i,1],index_btm_hsr[i,2]]\n  }\n  \n  for ( i in 1:nrow(index_hsr_btm))\n  {\n    index_hsr_btm$rgb1[i] = image_rgb[index_hsr_btm[i,1],index_hsr_btm[i,2]]\n  }\n  \n  index_ec_madi = cbind(index_ec_madi[,c(1:2)],data.frame(do.call('rbind', strsplit(as.character(index_ec_madi$rgb1),',',fixed=TRUE))))\n  colnames(index_ec_madi) = c(\"x\",\"y\",\"r\",\"g\",\"b\") \n  \n  index_madi_ec = cbind(index_madi_ec[,c(1:2)],data.frame(do.call('rbind', strsplit(as.character(index_madi_ec$rgb1),',',fixed=TRUE))))\n  colnames(index_madi_ec) = c(\"x\",\"y\",\"r\",\"g\",\"b\") \n  \n  index_hsr_btm = cbind(index_hsr_btm[,c(1:2)],data.frame(do.call('rbind', strsplit(as.character(index_hsr_btm$rgb1),',',fixed=TRUE))))\n  colnames(index_hsr_btm) = c(\"x\",\"y\",\"r\",\"g\",\"b\") \n  \n  index_btm_hsr = cbind(index_btm_hsr[,c(1:2)],data.frame(do.call('rbind', strsplit(as.character(index_btm_hsr$rgb1),',',fixed=TRUE))))\n  colnames(index_btm_hsr) = c(\"x\",\"y\",\"r\",\"g\",\"b\") \n  \n  ## Assigning Red Flag to the roads with Heavy Traffic\n  \n  index_ec_madi$red_flag = ifelse(as.numeric(paste(index_ec_madi$r)) > 200 & as.numeric(paste(index_ec_madi$g)) < 120 ,1,0)\n  index_madi_ec$red_flag = ifelse(as.numeric(paste(index_madi_ec$r)) > 200 & as.numeric(paste(index_madi_ec$g)) < 120 ,1,0)\n  index_hsr_btm$red_flag = ifelse(as.numeric(paste(index_hsr_btm$r)) > 200 & as.numeric(paste(index_hsr_btm$g)) < 120 ,1,0)\n  index_btm_hsr$red_flag = ifelse(as.numeric(paste(index_btm_hsr$r)) > 200 & as.numeric(paste(index_btm_hsr$g)) < 120 ,1,0)\n  \n  ## Assigning Amber Flag to the roads with Moderate Traffic\n  \n  index_ec_madi$amber_flag = ifelse(as.numeric(paste(index_ec_madi$r)) > 200 & as.numeric(paste(index_ec_madi$g)) > 140 & as.numeric(paste(index_ec_madi$b))<100,1,0)\n  index_madi_ec$amber_flag = ifelse(as.numeric(paste(index_madi_ec$r)) > 200 & as.numeric(paste(index_madi_ec$g)) > 140 & as.numeric(paste(index_madi_ec$b))<100,1,0)\n  index_hsr_btm$amber_flag = ifelse(as.numeric(paste(index_hsr_btm$r)) > 200 & as.numeric(paste(index_hsr_btm$g)) > 140 & as.numeric(paste(index_hsr_btm$b))<100,1,0)\n  index_btm_hsr$amber_flag = ifelse(as.numeric(paste(index_btm_hsr$r)) > 200 & as.numeric(paste(index_btm_hsr$g)) > 140 & as.numeric(paste(index_btm_hsr$b))<100 ,1,0)\n  \n  ### Calculation of all 4 distances \n  \n  latlon_dist <- function(origin,destination){\n    xml.url <- paste0('http://maps.googleapis.com/maps/api/distancematrix/xml?origins=',origin,'&destinations=',destination,'&mode=walking&sensor=false')\n    xmlfile <- xmlParse(getURL(xml.url))\n    dist <- xmlValue(xmlChildren(xpathApply(xmlfile,\"//distance\")[[1]])$value)\n    distance <- as.numeric(sub(\" km\",\"\",dist))\n    return(distance)\n  }\n\n  index_hsr_btm$row_num = seq.int(nrow(index_hsr_btm))\n  index_btm_hsr$row_num = seq.int(nrow(index_btm_hsr))\n  index_madi_ec$row_num = seq.int(nrow(index_madi_ec))\n  index_ec_madi$row_num = seq.int(nrow(index_ec_madi))\n  \n  ## Getting Immediate Red Pixels [Since the Image is marked Pixel by Pixel , the number of pixels will be directly proportional to the length of the corresponding road]\n  \n  hsr_btm_ri = ifelse(is.na(index_hsr_btm$row_num[index_hsr_btm$red_flag  == 0][1]),nrow(index_hsr_btm),index_hsr_btm$row_num[index_hsr_btm$red_flag  == 0][1]-1)\n  btm_hsr_ri = ifelse(is.na(index_btm_hsr$row_num[index_btm_hsr$red_flag  == 0][1]),nrow(index_btm_hsr),index_btm_hsr$row_num[index_btm_hsr$red_flag  == 0][1]-1)\n  madi_ec_ri = ifelse(is.na(index_madi_ec$row_num[index_madi_ec$red_flag  == 0][1]),nrow(index_madi_ec),index_madi_ec$row_num[index_madi_ec$red_flag  == 0][1]-1)\n  ec_madi_ri = ifelse(is.na(index_ec_madi$row_num[index_ec_madi$red_flag  == 0][1]),nrow(index_ec_madi),index_ec_madi$row_num[index_ec_madi$red_flag  == 0][1]-1)\n  \n  ## Getting Immediate Amber Pixels for all the 4 individual roads\n  \n  hsr_btm_ai = ifelse(is.na(index_hsr_btm$row_num[index_hsr_btm$amber_flag  == 0][1]),nrow(index_hsr_btm),index_hsr_btm$row_num[index_hsr_btm$amber_flag  == 0][1]-1)\n  btm_hsr_ai = ifelse(is.na(index_btm_hsr$row_num[index_btm_hsr$amber_flag  == 0][1]),nrow(index_btm_hsr),index_btm_hsr$row_num[index_btm_hsr$amber_flag  == 0][1]-1)\n  madi_ec_ai = ifelse(is.na(index_madi_ec$row_num[index_madi_ec$amber_flag  == 0][1]),nrow(index_madi_ec),index_madi_ec$row_num[index_madi_ec$amber_flag  == 0][1]-1)\n  ec_madi_ai = ifelse(is.na(index_ec_madi$row_num[index_ec_madi$amber_flag  == 0][1]),nrow(index_ec_madi),index_ec_madi$row_num[index_ec_madi$amber_flag  == 0][1]-1)\n  \n  ## Getting the Number of Red Pixels [ Heavy traffic ] on the entire stretch of the road\n  \n  hsr_btm_rw = sum(index_hsr_btm$red_flag)\n  btm_hsr_rw = sum(index_btm_hsr$red_flag)\n  madi_ec_rw = sum(index_madi_ec$red_flag)\n  ec_madi_rw = sum(index_ec_madi$red_flag)\n  \n  ## Getting the number of Amber Pixels [ Moderate Traffic ] on the entire stretch of the road\n  \n  hsr_btm_aw = sum(index_hsr_btm$amber_flag)\n  btm_hsr_aw = sum(index_btm_hsr$amber_flag)\n  madi_ec_aw = sum(index_madi_ec$amber_flag)\n  ec_madi_aw = sum(index_ec_madi$amber_flag)\n  \n  df_1 = data.frame(hsr_btm_time,btm_hsr_time,madiwala_ec_time,ec_madiwala_time,hsr_btm_ri,hsr_btm_ai,btm_hsr_ri,btm_hsr_ai,madi_ec_ri,madi_ec_ai,ec_madi_ri,ec_madi_ai,hsr_btm_rw,hsr_btm_aw,btm_hsr_rw,btm_hsr_aw,madi_ec_rw,madi_ec_aw,ec_madi_rw,ec_madi_aw,time)\n  df_raw  = rbind.fill(df_raw,df_1)\n  \n  ## Creating the Traffic Congestion Index [ Based on the Weights mentioned in Approach ]\n  \n  hsr_btm_tci = constant + alpha_wt*(hsr_btm_time) + alpha_ri*(hsr_btm_ri+0.4*hsr_btm_ai) + alpha_rw*(hsr_btm_rw+0.4*hsr_btm_aw) \n  btm_hsr_tci = constant + alpha_wt*(btm_hsr_time) + alpha_ri*(btm_hsr_ri+0.4*btm_hsr_ai) + alpha_rw*(btm_hsr_rw+0.4*btm_hsr_aw) \n  madi_ec_tci = constant + alpha_wt*(madiwala_ec_time) + alpha_ri*(madi_ec_ri+0.4*madi_ec_ai) + alpha_rw*(madi_ec_rw+0.4*madi_ec_aw) \n  ec_madi_tci = constant + alpha_wt*(ec_madiwala_time) + alpha_ri*(ec_madi_ri+0.4*ec_madi_ai) + alpha_rw*(ec_madi_rw+0.4*ec_madi_aw) \n  \n  tci_total = hsr_btm_tci +  btm_hsr_tci +  max(madi_ec_tci,ec_madi_tci)\n  \n  df = rbind.fill(df,data.frame(tci_total,hsr_btm_tci,btm_hsr_tci,madi_ec_tci,ec_madi_tci,time))\n  write.csv(df_raw,\"outputs/All_Variables.csv\",row.names = F)\n  write.csv(df,\"outputs/TCI.csv\")\n  \n  ## Calculating the individual Green times and the total cycle time for all the 4 signals\n  \n  hsr_btm_gt = round((hsr_btm_tci/tci_total)*(((cycle_time_max-cycle_time_min)/(tci_max-tci_min))*tci_total + 90)/5,0)*5\n  hsr_btm_gt = ifelse(hsr_btm_gt < 15, 15, hsr_btm_gt)\n  \n  btm_hsr_gt = round((btm_hsr_tci/tci_total)*(((cycle_time_max-cycle_time_min)/(tci_max-tci_min))*tci_total + 90)/5,0)*5\n  btm_hsr_gt = ifelse(btm_hsr_gt < 15, 15, btm_hsr_gt)\n  \n  madi_ec_gt = round((max(madi_ec_tci,ec_madi_tci)/tci_total)*(((cycle_time_max-cycle_time_min)/(tci_max-tci_min))*tci_total + 90)/5,0)*5\n  madi_ec_gt = ifelse(madi_ec_gt < 15, 15, madi_ec_gt)\n  \n  ec_madi_gt = round((max(madi_ec_tci,ec_madi_tci)/tci_total)*(((cycle_time_max-cycle_time_min)/(tci_max-tci_min))*tci_total + 90)/5,0)*5\n  ec_madi_gt = ifelse(ec_madi_gt < 15, 15, ec_madi_gt)\n  \n  tct = hsr_btm_gt + btm_hsr_gt + madi_ec_gt\n  \n  gt_data = rbind.fill(gt_data, data.frame(hsr_btm_gt,btm_hsr_gt,madi_ec_gt,ec_madi_gt,tct,time))\n  write.csv(gt_data,\"outputs/Tgt_data.csv\")\n  \n  ## Writing the JSON FIles for the Front End\n  \n  df_2 = cbind(df_1[,c(\"hsr_btm_time\",\"btm_hsr_time\",\"madiwala_ec_time\",\"ec_madiwala_time\")],data.frame(hsr_btm_gt,btm_hsr_gt,madi_ec_gt,ec_madi_gt,tct))\n  out1 = toJSON(df_2)\n  write(out1,\"outputs/json_1.txt\")\n  \n  df_3 = cbind(df_raw[,c(\"time\",\"hsr_btm_time\",\"btm_hsr_time\",\"madiwala_ec_time\",\"ec_madiwala_time\")],gt_data[,c(\"hsr_btm_gt\",\"btm_hsr_gt\",\"madi_ec_gt\",\"ec_madi_gt\")])\n  df_3$hsr_btm_cst = 70\n  df_3$btm_hsr_cst = 80\n  df_3$madi_ec_cst = 40\n  df_3$ec_madi_cst = 40\n  df_3$tct = df_3$hsr_btm_gt+df_3$btm_hsr_gt+df_3$madi_ec_gt\n  \n  ## Calculating the Impact Metrics [ Man Hours Saved , Fuel Saved and CO2 Emissions Reduced ]\n  \n  df_3$man_hours_saved = (((manhours_saved*df_3$tct*average_speed)/vehicle_length)*lanes)*people_per_vehicle*manhours_saved*df_3$tct/3600\n  df_3$fuel_saved = (df_3$tct*manhours_saved)*fuel_wasted/24/60/60/fuel_density\n  df_3$co2_reduced = (df_3$tct*manhours_saved)*co2_emissions/24/60/60\n  df_3 = toJSON(df_3)\n  write(df_3,\"outputs/json_time_series_trends.txt\")\n  \n  ## Keeping the system idle before the next cycle - \n    ## This will be dynamic as the cycle time is dynamic [deltime here is the code run time ]\n        # (During our runs on local laptops this was always found to be less than 60 seconds - Way less than min cycle time)\n  \n  cat(\"Total Cycle Time :\",gt_data$tct,\"\\n Green Times : \\n\",\"HSR Green Time : \",gt_data$hsr_btm_gt[nrow(gt_data)],\"\\n BTM Green Time : \",gt_data$btm_hsr_gt[nrow(gt_data)],\"\\n Madiwala & Bommanahalli Green Time : \",gt_data$madi_ec_gt[nrow(gt_data)])\n  \n  time2 = Sys.time()\n  deltime = difftime(time2,time1,units = \"secs\") ## This is the code run time in seconds\n  Sys.sleep(tct-deltime)\n   \n}\n",
    "created" : 1498991480081.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1671599692",
    "id" : "CB2C2EB2",
    "lastKnownWriteTime" : 1498991522,
    "path" : "C:/Sayantan_C/Projects/Gridlock/GridLock_Hackathon/Traffic_Signal_Optimization_GridlockHack_R.R",
    "project_path" : "Traffic_Signal_Optimization_GridlockHack_R.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}